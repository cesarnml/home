---
import BaseLayout from '../layouts/BaseLayout.astro';
import MusicToggle from '../components/MusicToggle.astro';
---

<BaseLayout title="Tetris | 1036 days" description="Play Tetris!">
  <div class="flex flex-col items-center gap-6">
    <h1 class="text-4xl font-bold bg-linear-to-r from-cyan-400 via-violet-400 to-fuchsia-400 bg-clip-text text-transparent">
      Tetris
    </h1>
    
    <div class="flex flex-col md:flex-row gap-6 items-start">
      <!-- Game Board -->
      <div class="relative">
        <canvas 
          id="tetris-canvas" 
          class="border-2 border-slate-700 rounded-lg bg-slate-900/80 max-w-full"
          width="300" 
          height="600"
        ></canvas>
        
        <!-- Music Toggle -->
        <MusicToggle class="absolute top-2.5 right-2.5" />
        
        <!-- Start Game Overlay -->
        <div id="start-screen" class="absolute inset-0 bg-slate-900/90 rounded-lg flex flex-col items-center justify-center gap-4">
          <p class="text-3xl font-bold bg-linear-to-r from-cyan-400 via-violet-400 to-fuchsia-400 bg-clip-text text-transparent">Tetris</p>
          <button 
            id="start-btn"
            class="px-8 py-3 bg-violet-600 hover:bg-violet-500 text-white font-medium rounded-lg transition-colors text-lg"
          >
            Play Game
          </button>
          <p class="text-xs text-slate-500 mt-2">Press any key to start</p>
        </div>
        
        <!-- Game Over Overlay -->
        <div id="game-over" class="hidden absolute inset-0 bg-slate-900/90 rounded-lg flex flex-col items-center justify-center gap-4">
          <p class="text-3xl font-bold text-fuchsia-400">Game Over!</p>
          <p class="text-xl text-slate-300">Score: <span id="final-score">0</span></p>
          <button 
            id="restart-btn"
            class="px-6 py-2 bg-violet-600 hover:bg-violet-500 text-white font-medium rounded-lg transition-colors"
          >
            Play Again
          </button>
        </div>
      </div>
      
      <!-- Side Panel -->
      <div class="flex flex-col gap-4 min-w-[180px]">
        <!-- Next Piece -->
        <div class="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
          <p class="text-sm text-slate-400 mb-2">Next</p>
          <canvas id="next-canvas" width="120" height="80" class="bg-slate-900/50 rounded"></canvas>
        </div>
        
        <!-- Score -->
        <div class="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
          <p class="text-sm text-slate-400">Score</p>
          <p id="score" class="text-2xl font-bold text-cyan-400">0</p>
        </div>
        
        <!-- Level -->
        <div class="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
          <p class="text-sm text-slate-400">Level</p>
          <p id="level" class="text-2xl font-bold text-violet-400">1</p>
        </div>
        
        <!-- Lines -->
        <div class="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
          <p class="text-sm text-slate-400">Lines</p>
          <p id="lines" class="text-2xl font-bold text-fuchsia-400">0</p>
        </div>
        
        <!-- Controls -->
        <div class="bg-slate-800/50 backdrop-blur-sm rounded-xl p-4 border border-slate-700/50">
          <p class="text-sm text-slate-400 mb-2">Controls</p>
          <div class="text-xs text-slate-500 space-y-1">
            <p><span class="text-slate-300">←→</span> Move</p>
            <p><span class="text-slate-300">↑</span> Rotate</p>
            <p><span class="text-slate-300">↓</span> Soft Drop</p>
            <p><span class="text-slate-300">Space</span> Hard Drop</p>
            <p><span class="text-slate-300">P</span> Pause</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Mobile Controls -->
    <div class="md:hidden flex flex-col gap-3 w-full max-w-xs">
      <div class="grid grid-cols-3 gap-2">
        <button id="btn-left" class="p-4 bg-slate-800 rounded-lg active:bg-violet-600 text-2xl transition-colors touch-manipulation">←</button>
        <button id="btn-rotate" class="p-4 bg-slate-800 rounded-lg active:bg-violet-600 text-2xl transition-colors touch-manipulation">↻</button>
        <button id="btn-right" class="p-4 bg-slate-800 rounded-lg active:bg-violet-600 text-2xl transition-colors touch-manipulation">→</button>
      </div>
      <div class="grid grid-cols-2 gap-2">
        <button id="btn-down" class="p-4 bg-slate-800 rounded-lg active:bg-violet-600 text-2xl transition-colors touch-manipulation">↓</button>
        <button id="btn-drop" class="p-4 bg-violet-600 rounded-lg active:bg-violet-500 font-medium transition-colors touch-manipulation">⬇ Drop</button>
      </div>
      <button id="btn-pause" class="p-3 bg-slate-700 rounded-lg active:bg-slate-600 text-sm font-medium transition-colors touch-manipulation">⏸ Pause</button>
    </div>
  </div>
</BaseLayout>

<script>
  // ============== MUSIC SYSTEM ==============
  let audioCtx: AudioContext | null = null;
  let isMuted = false;
  let musicPlaying = false;
  let currentNoteTimeout: number | null = null;
  
  // Tetris theme (Korobeiniki) - simplified melody
  const TETRIS_MELODY = [
    // Note: [frequency, duration in ms]
    [659, 400], [494, 200], [523, 200], [587, 400], [523, 200], [494, 200],
    [440, 400], [440, 200], [523, 200], [659, 400], [587, 200], [523, 200],
    [494, 400], [494, 200], [523, 200], [587, 400], [659, 400],
    [523, 400], [440, 400], [440, 400], [0, 200],
    [587, 400], [698, 200], [880, 400], [784, 200], [698, 200],
    [659, 600], [523, 200], [659, 400], [587, 200], [523, 200],
    [494, 400], [494, 200], [523, 200], [587, 400], [659, 400],
    [523, 400], [440, 400], [440, 400], [0, 400],
  ];
  
  function initAudio() {
    if (!audioCtx) {
      audioCtx = new AudioContext();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }
  
  function playNote(frequency: number, duration: number) {
    if (!audioCtx || isMuted || frequency === 0) return;
    
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    oscillator.type = 'square';
    oscillator.frequency.value = frequency;
    
    gainNode.gain.value = 0.1;
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration / 1000);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration / 1000);
  }
  
  let melodyIndex = 0;
  function playMelody() {
    if (isMuted || gameOver) {
      musicPlaying = false;
      return;
    }
    
    musicPlaying = true;
    const [freq, duration] = TETRIS_MELODY[melodyIndex];
    playNote(freq, duration * 0.9);
    
    melodyIndex = (melodyIndex + 1) % TETRIS_MELODY.length;
    currentNoteTimeout = window.setTimeout(playMelody, duration);
  }
  
  function startMusic() {
    if (!musicPlaying && !isMuted) {
      initAudio();
      melodyIndex = 0;
      playMelody();
    }
  }
  
  function stopMusic() {
    musicPlaying = false;
    if (currentNoteTimeout) {
      clearTimeout(currentNoteTimeout);
      currentNoteTimeout = null;
    }
  }
  
  function toggleMute() {
    isMuted = !isMuted;
    const soundOn = document.getElementById('sound-on')!;
    const soundOff = document.getElementById('sound-off')!;
    
    if (isMuted) {
      soundOn.classList.add('hidden');
      soundOff.classList.remove('hidden');
      stopMusic();
    } else {
      soundOn.classList.remove('hidden');
      soundOff.classList.add('hidden');
      if (!gameOver) {
        startMusic();
      }
    }
  }
  
  // Mute button
  document.getElementById('mute-btn')?.addEventListener('click', toggleMute);
  
  // ============== CANVAS SETUP ==============
  const canvas = document.getElementById('tetris-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;
  const nextCanvas = document.getElementById('next-canvas') as HTMLCanvasElement;
  const nextCtx = nextCanvas.getContext('2d')!;
  
  // Game constants
  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 30;
  const NEXT_BLOCK_SIZE = 20;
  
  // Colors matching site theme
  const COLORS = [
    null,
    '#22d3ee', // cyan - I
    '#fbbf24', // yellow - O
    '#a78bfa', // violet - T
    '#34d399', // green - S
    '#f87171', // red - Z
    '#60a5fa', // blue - J
    '#fb923c', // orange - L
  ];
  
  // Tetromino shapes
  const SHAPES = [
    null,
    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
    [[2,2], [2,2]], // O
    [[0,3,0], [3,3,3], [0,0,0]], // T
    [[0,4,4], [4,4,0], [0,0,0]], // S
    [[5,5,0], [0,5,5], [0,0,0]], // Z
    [[6,0,0], [6,6,6], [0,0,0]], // J
    [[0,0,7], [7,7,7], [0,0,0]], // L
  ];
  
  // Game state
  let board: number[][] = [];
  let score = 0;
  let lines = 0;
  let level = 1;
  let gameOver = false;
  let paused = false;
  let currentPiece: { shape: number[][], x: number, y: number, type: number } | null = null;
  let nextPiece: number = 0;
  let dropInterval: number;
  let lastDrop = 0;
  
  // Initialize board
  function initBoard() {
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
  }
  
  // Create a new piece
  function createPiece(type: number) {
    const shape = SHAPES[type]!.map(row => [...row]);
    return {
      shape,
      x: Math.floor(COLS / 2) - Math.floor(shape[0].length / 2),
      y: 0,
      type
    };
  }
  
  // Get random piece type
  function randomPiece(): number {
    return Math.floor(Math.random() * 7) + 1;
  }
  
  // Draw a single block
  function drawBlock(ctx: CanvasRenderingContext2D, x: number, y: number, color: string, size: number) {
    ctx.fillStyle = color;
    ctx.fillRect(x * size, y * size, size - 1, size - 1);
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(x * size, y * size, size - 1, 3);
    ctx.fillRect(x * size, y * size, 3, size - 1);
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(x * size + size - 4, y * size, 3, size - 1);
    ctx.fillRect(x * size, y * size + size - 4, size - 1, 3);
  }
  
  // Draw the board
  function drawBoard() {
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, canvas.height);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(canvas.width, y * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Draw placed blocks
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) {
          drawBlock(ctx, x, y, COLORS[board[y][x]]!, BLOCK_SIZE);
        }
      }
    }
  }
  
  // Draw current piece
  function drawPiece() {
    if (!currentPiece) return;
    
    // Draw actual piece
    currentPiece.shape.forEach((row, dy) => {
      row.forEach((value, dx) => {
        if (value) {
          drawBlock(ctx, currentPiece!.x + dx, currentPiece!.y + dy, COLORS[value]!, BLOCK_SIZE);
        }
      });
    });
  }
  
  // Draw next piece preview
  function drawNext() {
    nextCtx.fillStyle = '#0f172a';
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    if (!nextPiece) return;
    
    const shape = SHAPES[nextPiece]!;
    const offsetX = (nextCanvas.width / NEXT_BLOCK_SIZE - shape[0].length) / 2;
    const offsetY = (nextCanvas.height / NEXT_BLOCK_SIZE - shape.length) / 2;
    
    shape.forEach((row, dy) => {
      row.forEach((value, dx) => {
        if (value) {
          drawBlock(nextCtx, offsetX + dx, offsetY + dy, COLORS[value]!, NEXT_BLOCK_SIZE);
        }
      });
    });
  }
  
  // Check collision
  function collides(piece: typeof currentPiece, offsetX = 0, offsetY = 0): boolean {
    if (!piece) return false;
    
    return piece.shape.some((row, dy) =>
      row.some((value, dx) => {
        if (!value) return false;
        const newX = piece.x + dx + offsetX;
        const newY = piece.y + dy + offsetY;
        return (
          newX < 0 ||
          newX >= COLS ||
          newY >= ROWS ||
          (newY >= 0 && board[newY][newX])
        );
      })
    );
  }
  
  // Rotate piece
  function rotate() {
    if (!currentPiece) return;
    
    const rotated = currentPiece.shape[0].map((_, i) =>
      currentPiece!.shape.map(row => row[i]).reverse()
    );
    
    const prevShape = currentPiece.shape;
    currentPiece.shape = rotated;
    
    // Wall kick
    if (collides(currentPiece)) {
      if (!collides(currentPiece, -1)) {
        currentPiece.x -= 1;
      } else if (!collides(currentPiece, 1)) {
        currentPiece.x += 1;
      } else if (!collides(currentPiece, -2)) {
        currentPiece.x -= 2;
      } else if (!collides(currentPiece, 2)) {
        currentPiece.x += 2;
      } else {
        currentPiece.shape = prevShape;
      }
    }
  }
  
  // Move piece
  function move(dir: number) {
    if (!currentPiece || gameOver || paused) return;
    if (!collides(currentPiece, dir)) {
      currentPiece.x += dir;
    }
  }
  
  // Drop piece one row
  function drop() {
    if (!currentPiece || gameOver || paused) return;
    
    if (!collides(currentPiece, 0, 1)) {
      currentPiece.y++;
    } else {
      lockPiece();
    }
  }
  
  // Hard drop
  function hardDrop() {
    if (!currentPiece || gameOver || paused) return;
    
    while (!collides(currentPiece, 0, 1)) {
      currentPiece.y++;
      score += 2;
    }
    lockPiece();
  }
  
  // Lock piece to board
  function lockPiece() {
    if (!currentPiece) return;
    
    currentPiece.shape.forEach((row, dy) => {
      row.forEach((value, dx) => {
        if (value && currentPiece!.y + dy >= 0) {
          board[currentPiece!.y + dy][currentPiece!.x + dx] = value;
        }
      });
    });
    
    clearLines();
    spawnPiece();
  }
  
  // Clear completed lines
  function clearLines() {
    let cleared = 0;
    
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell !== 0)) {
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        cleared++;
        y++; // Check same row again
      }
    }
    
    if (cleared > 0) {
      // Scoring: 100, 300, 500, 800 for 1, 2, 3, 4 lines
      const points = [0, 100, 300, 500, 800][cleared] * level;
      score += points;
      lines += cleared;
      
      // Level up every 10 lines
      level = Math.floor(lines / 10) + 1;
      dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      
      updateUI();
    }
  }
  
  // Spawn new piece
  function spawnPiece() {
    currentPiece = createPiece(nextPiece || randomPiece());
    nextPiece = randomPiece();
    
    if (collides(currentPiece)) {
      gameOver = true;
      stopMusic();
      showGameOver();
    }
    
    drawNext();
  }
  
  // Update UI
  function updateUI() {
    document.getElementById('score')!.textContent = score.toString();
    document.getElementById('level')!.textContent = level.toString();
    document.getElementById('lines')!.textContent = lines.toString();
  }
  
  // Show game over
  function showGameOver() {
    document.getElementById('final-score')!.textContent = score.toString();
    document.getElementById('game-over')!.classList.remove('hidden');
  }
  
  // Start game (from initial paused state)
  let gameStarted = false;
  
  function startGame() {
    if (gameStarted) return;
    gameStarted = true;
    paused = false;
    document.getElementById('start-screen')!.classList.add('hidden');
    startMusic();
  }
  
  // Reset game
  function resetGame() {
    initBoard();
    score = 0;
    lines = 0;
    level = 1;
    gameOver = false;
    paused = true; // Start paused until player clicks play
    gameStarted = false;
    dropInterval = 1000;
    lastDrop = 0;
    nextPiece = randomPiece();
    spawnPiece();
    updateUI();
    document.getElementById('game-over')!.classList.add('hidden');
    document.getElementById('start-screen')!.classList.remove('hidden');
  }
  
  // Game loop
  function gameLoop(timestamp: number) {
    if (!paused && !gameOver) {
      if (timestamp - lastDrop > dropInterval) {
        drop();
        lastDrop = timestamp;
      }
    }
    
    drawBoard();
    drawPiece();
    
    requestAnimationFrame(gameLoop);
  }
  
  // Keyboard controls
  document.addEventListener('keydown', (e) => {
    // Start game on first key press
    if (!gameStarted && !gameOver) {
      startGame();
      return;
    }
    
    // Start music on first interaction
    if (!musicPlaying && !isMuted && !gameOver) {
      startMusic();
    }
    
    if (gameOver) return;
    
    switch (e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        move(-1);
        break;
      case 'ArrowRight':
        e.preventDefault();
        move(1);
        break;
      case 'ArrowDown':
        e.preventDefault();
        drop();
        score += 1;
        updateUI();
        break;
      case 'ArrowUp':
        e.preventDefault();
        rotate();
        break;
      case ' ':
        e.preventDefault();
        hardDrop();
        updateUI();
        break;
      case 'p':
      case 'P':
        paused = !paused;
        if (paused) {
          stopMusic();
        } else {
          startMusic();
        }
        break;
      case 'm':
      case 'M':
        toggleMute();
        break;
    }
  });
  
  // Mobile controls
  function handleMobileAction(action: () => void) {
    if (!gameStarted && !gameOver) {
      startGame();
      return;
    }
    if (!musicPlaying && !isMuted) startMusic();
    action();
  }
  
  document.getElementById('btn-left')?.addEventListener('click', () => {
    handleMobileAction(() => move(-1));
  });
  document.getElementById('btn-right')?.addEventListener('click', () => {
    handleMobileAction(() => move(1));
  });
  document.getElementById('btn-rotate')?.addEventListener('click', () => {
    handleMobileAction(() => rotate());
  });
  document.getElementById('btn-down')?.addEventListener('click', () => {
    handleMobileAction(() => {
      drop();
      score += 1;
      updateUI();
    });
  });
  document.getElementById('btn-drop')?.addEventListener('click', () => {
    handleMobileAction(() => {
      hardDrop();
      updateUI();
    });
  });
  document.getElementById('btn-pause')?.addEventListener('click', () => {
    if (!gameStarted) return;
    paused = !paused;
    const pauseBtn = document.getElementById('btn-pause')!;
    pauseBtn.textContent = paused ? '▶ Resume' : '⏸ Pause';
    if (paused) {
      stopMusic();
    } else {
      startMusic();
    }
  });
  
  // Touch swipe gestures on canvas
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  
  canvas.addEventListener('touchstart', (e) => {
    if (!gameStarted && !gameOver) {
      startGame();
      return;
    }
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchStartTime = Date.now();
  }, { passive: true });
  
  canvas.addEventListener('touchend', (e) => {
    if (!gameStarted || gameOver || paused) return;
    
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const touchDuration = Date.now() - touchStartTime;
    
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    const minSwipe = 30;
    
    // Tap to rotate (quick touch with minimal movement)
    if (touchDuration < 200 && Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20) {
      rotate();
      return;
    }
    
    // Swipe detection
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      // Horizontal swipe
      if (deltaX > minSwipe) {
        move(1); // Right
      } else if (deltaX < -minSwipe) {
        move(-1); // Left
      }
    } else {
      // Vertical swipe
      if (deltaY > minSwipe * 2) {
        // Long swipe down = hard drop
        hardDrop();
        updateUI();
      } else if (deltaY > minSwipe) {
        // Short swipe down = soft drop
        drop();
        score += 1;
        updateUI();
      }
    }
  }, { passive: true });
  
  // Start button
  document.getElementById('start-btn')?.addEventListener('click', startGame);
  
  // Restart button
  document.getElementById('restart-btn')?.addEventListener('click', resetGame);
  
  // Start game
  resetGame();
  requestAnimationFrame(gameLoop);
</script>
